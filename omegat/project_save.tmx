<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="3.0.5" segtype="sentence" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN-US">
        <seg>((&lt; a b) b)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085502Z" creationid="JC Helary" creationdate="20130707T085502Z">
        <seg>((&lt; a b) b)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>((&lt; x 0) (- x))))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T105324Z" creationid="JC Helary" creationdate="20130706T105324Z">
        <seg>((&lt; x 0) (- x))))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>((= b 4) (+ 6 7 a))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085458Z" creationid="JC Helary" creationdate="20130707T085458Z">
        <seg>((= b 4) (+ 6 7 a))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>((= x 0) 0)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T105322Z" creationid="JC Helary" creationdate="20130706T105322Z">
        <seg>((= x 0) 0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>((if (&gt; b 0) + -) a b))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085847Z" creationid="JC Helary" creationdate="20130707T085847Z">
        <seg>((if (&gt; b 0) + -) a b))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(* (+ 2 (* 4 6))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T125142Z">
        <seg>(* (+ 2 (* 4 6))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(* (cond ((&gt; a b) a)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085501Z" creationid="JC Helary" creationdate="20130707T085501Z">
        <seg>(* (cond ((&gt; a b) a)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(* 25 4 12)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T084533Z">
        <seg>(* 25 4 12)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(* 5 99)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T011155Z">
        <seg>(* 5 99)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(* 5 size)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130522T151702Z">
        <seg>(* 5 taille)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(* pi (* radius radius))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130522T151724Z">
        <seg>(* pi (* rayon rayon))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(* x x)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T110123Z">
        <seg>(* x x)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(+ (* 2 4)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T085219Z">
        <seg>(+ (* 2 4)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(+ (* 2 4) (- 4 6))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085450Z" creationid="JC Helary" creationdate="20130707T085450Z">
        <seg>(+ (* 2 4) (- 4 6))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(+ (* 3</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T085217Z">
        <seg>(+ (* 3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T085131Z">
        <seg>(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(+ (* 3 5) (- 10 6))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T085008Z">
        <seg>(+ (* 3 5) (- 10 6))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(+ (* 6 6) (* 10 10))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T130326Z">
        <seg>(+ (* 6 6) (* 10 10))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(+ (- 10 7)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T085221Z">
        <seg>(+ (- 10 7)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(+ (square 6) (square 10))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T001042Z">
        <seg>(+ (carré 6) (carré 10))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(+ (square x) (square y))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T110258Z">
        <seg>(+ (carré x) (carré y))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(+ (square x) (square y)))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T110449Z">
        <seg>(+ (carré x) (carré y)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(+ 137 349)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T011149Z">
        <seg>(+ 137 349)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(+ 2.7 10)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T011159Z">
        <seg>(+ 2.7 10)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(+ 21 35 12 7)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T084531Z">
        <seg>(+ 21 35 12 7)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(+ 2 (if (&gt; b a) b a))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085500Z" creationid="JC Helary" creationdate="20130707T085500Z">
        <seg>(+ 2 (if (&gt; b a) b a))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(+ 36 100)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T130328Z">
        <seg>(+ 36 100)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(+ 3 5)))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T085220Z">
        <seg>(+ 3 5)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(+ 3 5 7))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T125143Z">
        <seg>(+ 3 5 7))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(+ 5 3 4)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085448Z" creationid="JC Helary" creationdate="20130707T085448Z">
        <seg>(+ 5 3 4)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(+ a 1))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085504Z" creationid="JC Helary" creationdate="20130707T085504Z">
        <seg>(+ a 1))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(+ a b (* a b))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085453Z" creationid="JC Helary" creationdate="20130707T085453Z">
        <seg>(+ a b (* a b))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(+    (* (+ 5 1) (+ 5 1))   (* (* 5 2) (* 5 2)))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T105836Z">
        <seg>(+    (* (+ 5 1) (+ 5 1))   (* (* 5 2) (* 5 2)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(+    (square (+ 5 1))      (square (* 5 2))  )</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T105835Z">
        <seg>(+    (carré (+ 5 1))      (carré (* 5 2))  )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(+         (* 6 6)             (* 10 10))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T105849Z">
        <seg>(+         (* 6 6)             (* 10 10))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(+           36                   100)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T105850Z">
        <seg>(+           36                   100)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(- 1000 334)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T011153Z">
        <seg>(- 1000 334)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(- 9 1)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085449Z" creationid="JC Helary" creationdate="20130707T085449Z">
        <seg>(- 9 1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(- x)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T111148Z" creationid="JC Helary" creationdate="20130706T111148Z">
        <seg>(- x)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(/ 10 5)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T011157Z">
        <seg>(/ 10 5)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(/ 6 2)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085449Z" creationid="JC Helary" creationdate="20130707T085449Z">
        <seg>(/ 6 2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(&lt;&lt;e0&gt;p&lt;s1&gt;2&lt;/s1&gt;&lt;/e0&gt;&gt; &lt;&lt;e2&gt;e&lt;s3&gt;2&lt;/s3&gt;&lt;/e2&gt;&gt;)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T105342Z" creationid="JC Helary" creationdate="20130706T105342Z">
        <seg>(&lt;&lt;e0&gt;p&lt;s1&gt;2&lt;/s1&gt;&lt;/e0&gt;&gt; &lt;&lt;e2&gt;e&lt;s3&gt;2&lt;/s3&gt;&lt;/e2&gt;&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(&lt;&lt;e0&gt;p&lt;s1&gt;&lt;e2&gt;n&lt;/e2&gt;&lt;/s1&gt;&lt;/e0&gt;&gt; &lt;&lt;e3&gt;e&lt;s4&gt;&lt;e5&gt;n&lt;/e5&gt;&lt;/s4&gt;&lt;/e3&gt;&gt;))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T105343Z" creationid="JC Helary" creationdate="20130706T105343Z">
        <seg>(&lt;&lt;e0&gt;p&lt;s1&gt;&lt;e2&gt;n&lt;/e2&gt;&lt;/s1&gt;&lt;/e0&gt;&gt; &lt;&lt;e3&gt;e&lt;s4&gt;&lt;e5&gt;n&lt;/e5&gt;&lt;/s4&gt;&lt;/e3&gt;&gt;))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(= a b)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085454Z" creationid="JC Helary" creationdate="20130707T085454Z">
        <seg>(= a b)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Later we will discover that they are really not so distinct.) Informally, data is ``stuff'' that we want to manipulate, and procedures are descriptions of the rules for manipulating the data.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T123618Z">
        <seg>(Nous découvrirons plus tard que ces deux types d'éléments ne sont pas si distincts que ça.) De manière informelle, les données sont les « trucs » que nous voulons manipuler et les procédures sont des descriptions des règles de manipulation des données.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(More precisely, the expression that you type consists of the numerals that represent the number in base 10.) If you present Lisp with a number</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T010832Z">
        <seg>(Ou plus précisément, l'expression saisie est le signe qui représente le nombre en base 10.) Si vous présentez à Lisp un nombre</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(See exercise &lt;a4&gt;1.5&lt;/a4&gt; for an instance of an ``illegitimate'' value where normal-order and applicative-order evaluation do not give the same result.)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T110730Z">
        <seg>(Voir l'exercice &lt;a4&gt;1.5&lt;/a4&gt; pour un exemple de valeur « illégitime » où les deux types d'évaluation ne produisent pas le même résultat.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(That is, &lt;t5&gt;(define x 3)&lt;/t5&gt; is not a combination.)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T044011Z">
        <seg>(En d'autres termes, &lt;t5&gt;(define x 3)&lt;/t5&gt; n'est pas une combinaison).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(and &lt;&lt;e0&gt;e&lt;s1&gt;1&lt;/s1&gt;&lt;/e0&gt;&gt; &lt;t2&gt;...&lt;/t2&gt; &lt;&lt;e3&gt;e&lt;s4&gt;&lt;e5&gt;n&lt;/e5&gt;&lt;/s4&gt;&lt;/e3&gt;&gt;)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T111917Z" creationid="JC Helary" creationdate="20130706T111917Z">
        <seg>(and &lt;&lt;e0&gt;e&lt;s1&gt;1&lt;/s1&gt;&lt;/e0&gt;&gt; &lt;t2&gt;...&lt;/t2&gt; &lt;&lt;e3&gt;e&lt;s4&gt;&lt;e5&gt;n&lt;/e5&gt;&lt;/s4&gt;&lt;/e3&gt;&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(and (&gt; x 5) (&lt; x 10))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085218Z" creationid="JC Helary" creationdate="20130707T085218Z">
        <seg>(and (&gt; x 5) (&lt; x 10))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(cond ((&lt; x 0) (- x))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T110526Z" creationid="JC Helary" creationdate="20130706T110526Z">
        <seg>(cond ((&lt; x 0) (- x))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(cond ((= a 4) 6)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085458Z" creationid="JC Helary" creationdate="20130707T085458Z">
        <seg>(cond ((= a 4) 6)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(cond ((&gt; x 0) x)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T105320Z" creationid="JC Helary" creationdate="20130706T105320Z">
        <seg>(cond ((&gt; x 0) x)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(cond (&lt;&lt;e0&gt;p&lt;s1&gt;1&lt;/s1&gt;&lt;/e0&gt;&gt; &lt;&lt;e2&gt;e&lt;s3&gt;1&lt;/s3&gt;&lt;/e2&gt;&gt;)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T105340Z" creationid="JC Helary" creationdate="20130706T105340Z">
        <seg>(cond (&lt;&lt;e0&gt;p&lt;s1&gt;1&lt;/s1&gt;&lt;/e0&gt;&gt; &lt;&lt;e2&gt;e&lt;s3&gt;1&lt;/s3&gt;&lt;/e2&gt;&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(define (&lt;&lt;e0&gt;name&lt;/e0&gt;&gt; &lt;&lt;e1&gt;formal parameters&lt;/e1&gt;&gt;) &lt;&lt;e2&gt;body&lt;/e2&gt;&gt;)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T104555Z">
        <seg>(define (&lt;&lt;e0&gt;nom&lt;/e0&gt;&gt; &lt;&lt;e1&gt;paramètres formels&lt;/e1&gt;&gt;) &lt;&lt;e2&gt;corps&lt;/e2&gt;&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(define (&gt;= x y)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085304Z" creationid="JC Helary" creationdate="20130707T085304Z">
        <seg>(define (&gt;= x y)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(define (a-plus-abs-b a b)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085843Z" creationid="JC Helary" creationdate="20130707T085843Z">
        <seg>(define (a-plus-abs-b a b)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(define (abs x)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T105317Z" creationid="JC Helary" creationdate="20130706T105317Z">
        <seg>(define (abs x)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(define (f a)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T130350Z">
        <seg>(define (f a)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(define (p) (p))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T133240Z" creationid="JC Helary" creationdate="20130707T133240Z">
        <seg>(define (p) (p))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(define (square x) (* x x))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T104205Z">
        <seg>(define (carré x) (* x x))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(define (square  x)        (*         x     x))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T104235Z">
        <seg>(define (carré  x)        (*         x     x))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(define (sum-of-squares x y)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T110440Z">
        <seg>(define (somme-de-carrés x y)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(define (test x y)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T133241Z" creationid="JC Helary" creationdate="20130707T133241Z">
        <seg>(define (test x y)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(define a 3)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085451Z" creationid="JC Helary" creationdate="20130707T085451Z">
        <seg>(define a 3)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(define b (+ a 1))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085452Z" creationid="JC Helary" creationdate="20130707T085452Z">
        <seg>(define b (+ a 1))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(define circumference (* 2 pi radius))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T123435Z">
        <seg>(define circonference (* 2 pi rayon))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(define pi 3.14159)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130522T151645Z">
        <seg>(define pi 3.14159)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(define radius 10)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130522T151651Z">
        <seg>(define rayon 10)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(define size 2)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130522T151708Z">
        <seg>(define taille 2)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(else -1))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085502Z" creationid="JC Helary" creationdate="20130707T085502Z">
        <seg>(else -1))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(else 25))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085459Z" creationid="JC Helary" creationdate="20130707T085459Z">
        <seg>(else 25))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(else x)))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T110527Z" creationid="JC Helary" creationdate="20130706T110527Z">
        <seg>(else x)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(f 5)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T130340Z">
        <seg>(f 5)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(if (&lt; x 0)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T111147Z" creationid="JC Helary" creationdate="20130706T111147Z">
        <seg>(if (&lt; x 0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(if (= x 0)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T133242Z" creationid="JC Helary" creationdate="20130707T133242Z">
        <seg>(if (= x 0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(if (and (&gt; b a) (&lt; b (* a b)))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085456Z" creationid="JC Helary" creationdate="20130707T085456Z">
        <seg>(if (and (&gt; b a) (&lt; b (* a b)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(if &lt;&lt;e0&gt;predicate&lt;/e0&gt;&gt; &lt;&lt;e1&gt;consequent&lt;/e1&gt;&gt; &lt;&lt;e2&gt;alternative&lt;/e2&gt;&gt;)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T023950Z" creationid="JC Helary" creationdate="20130706T111304Z">
        <seg>(if &lt;&lt;e0&gt;proposition&lt;/e0&gt;&gt; &lt;&lt;e1&gt;conséquence&lt;/e1&gt;&gt; &lt;&lt;e2&gt;alternative&lt;/e2&gt;&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(not &lt;&lt;e0&gt;e&lt;/e0&gt;&gt;)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T112305Z" creationid="JC Helary" creationdate="20130706T112305Z">
        <seg>(not &lt;&lt;e0&gt;e&lt;/e0&gt;&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(not (&lt; x y)))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085319Z" creationid="JC Helary" creationdate="20130707T085319Z">
        <seg>(not (&lt; x y)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(or &lt;&lt;e0&gt;e&lt;s1&gt;1&lt;/s1&gt;&lt;/e0&gt;&gt; &lt;t2&gt;...&lt;/t2&gt; &lt;&lt;e3&gt;e&lt;s4&gt;&lt;e5&gt;n&lt;/e5&gt;&lt;/s4&gt;&lt;/e3&gt;&gt;)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T112149Z" creationid="JC Helary" creationdate="20130706T112149Z">
        <seg>(or &lt;&lt;e0&gt;e&lt;s1&gt;1&lt;/s1&gt;&lt;/e0&gt;&gt; &lt;t2&gt;...&lt;/t2&gt; &lt;&lt;e3&gt;e&lt;s4&gt;&lt;e5&gt;n&lt;/e5&gt;&lt;/s4&gt;&lt;/e3&gt;&gt;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(or (&gt; x y) (= x y)))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085306Z" creationid="JC Helary" creationdate="20130707T085306Z">
        <seg>(or (&gt; x y) (= x y)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(square (+ 2 5))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T110129Z">
        <seg>(carré (+ 2 5))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(square (square 3))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T110138Z">
        <seg>(carré (carré 3))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(square 21)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T105905Z">
        <seg>(carré 21)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(sum-of-squares (+ 5 1) (* 5 2))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130624T234439Z">
        <seg>(somme-de-carrés (+ 5 1) (* 5 2))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(sum-of-squares (+ a 1) (* a 2))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130624T234408Z">
        <seg>(somme-de-carrés (+ a 1) (* a 2)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(sum-of-squares (+ a 1) (* a 2)))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T110621Z">
        <seg>(somme-de-carrés (+ a 1) (* a 2)))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(sum-of-squares 3 4)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T110457Z">
        <seg>(somme-de-carrés 3 4)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(test 0 (p))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T133253Z" creationid="JC Helary" creationdate="20130707T133253Z">
        <seg>(test 0 (p))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>0</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T133243Z" creationid="JC Helary" creationdate="20130707T133243Z">
        <seg>0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1.1.1  Expressions</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130514T052655Z">
        <seg>1.1.1  Expressions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1.1.2  Naming and the Environment</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130521T053320Z">
        <seg>1.1.2 Les noms et l'environnement</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1.1.3  Evaluating Combinations</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T124402Z">
        <seg>1.1.3 Évaluation de combinaisons</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1.1.4  Compound Procedures</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T042404Z">
        <seg>1.1.4 Procédures composées</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1.1.5  The Substitution Model for Procedure Application</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130624T232127Z">
        <seg>1.1.5 Le modèle de substitution pour l'application des procédures</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1.1.6  Conditional Expressions and Predicates</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T023549Z">
        <seg>1.1.6 Expressions conditionnelles et propositions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1.1  The Elements of Programming</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130513T154432Z">
        <seg>1.1 Les éléments de la programmation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1.2  Procedures and the Processes They Generate</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130625T132027Z" creationid="jchelary" creationdate="20130625T132027Z">
        <seg>1.2 Procédures et processus générés</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1.  Evaluate the subexpressions of the combination.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T124611Z">
        <seg>1. Évaluer les sous-expressions de la combinaison.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>10</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130522T151618Z">
        <seg>10</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>12.7</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T011202Z">
        <seg>12.7</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1200</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T084535Z">
        <seg>1200</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>136</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T130330Z">
        <seg>136</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>19</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T085010Z">
        <seg>19</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T011158Z">
        <seg>2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2.  Apply the procedure that is the value of the leftmost subexpression (the operator) to the arguments that are the values of the other subexpressions (the operands).</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T124651Z">
        <seg>2. Appliquer la procédure qui est la valeur de la sous-expression la plus à gauche (l'opérateur) aux arguments qui sont les valeurs des autres sous-expressions (les opérandes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>25</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T130351Z">
        <seg>25</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>314.159</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130522T151725Z">
        <seg>314.159</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>441</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T130402Z">
        <seg>441</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>486</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T010834Z">
        <seg>486</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>49</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T130400Z">
        <seg>49</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>495</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T011156Z">
        <seg>495</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>6))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T085224Z">
        <seg>6))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>62.8318</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130524T091301Z">
        <seg>62.8318</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>666</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T011154Z">
        <seg>666</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>75</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T084532Z">
        <seg>75</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>81</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T130359Z">
        <seg>81</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;1.1.1  Expressions&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130514T045310Z">
        <seg>&lt;a0&gt;1.1.1  Expressions&lt;/a0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;1.1.2  Naming and the Environment&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130514T045324Z">
        <seg>&lt;a0&gt;1.1.2  Les noms et l'environnement&lt;/a0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;1.1.3  Evaluating Combinations&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130514T045332Z">
        <seg>&lt;a0&gt;1.1.3  Évaluation de combinaisons&lt;/a0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;1.1.4  Compound Procedures&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130514T045339Z">
        <seg>&lt;a0&gt;1.1.4  Procédures composées&lt;/a0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;1.1  The Elements of Programming&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130514T045306Z">
        <seg>&lt;a0&gt;1.1  Les éléments de la programmation&lt;/a0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;1  Building Abstractions with Procedures&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130514T045254Z">
        <seg>&lt;a0&gt;1  Créer des abstractions à l'aide de procédures&lt;/a0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;&lt;i1&gt;&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130513T153009Z">
        <seg>&lt;a0&gt;&lt;i1&gt;&lt;/a0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Acknowledgments&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130514T044935Z">
        <seg>&lt;a0&gt;Remerciements&lt;/a0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Foreword&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130513T155144Z">
        <seg>&lt;a0&gt;Avant-propos&lt;/a0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Preface to the First Edition&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130513T155206Z">
        <seg>&lt;a0&gt;Préface à la première édition&lt;/a0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a0&gt;Preface to the Second Edition&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130513T155159Z">
        <seg>&lt;a0&gt;Préface à la seconde édition&lt;/a0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a2&gt;&lt;/a2&gt;Each special form has its own evaluation rule.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T102944Z">
        <seg>&lt;a2&gt;&lt;/a2&gt;Chaque forme spéciale a sa propre règle d'évaluation.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;a3&gt;&lt;/a3&gt;&lt;a4&gt;&lt;/a4&gt;&lt;a5&gt;&lt;/a5&gt;Evaluating the definition creates this compound procedure and associates it with the name &lt;t6&gt;square&lt;/t6&gt;.&lt;a7&gt;&lt;s8&gt;&lt;s9&gt;12&lt;/s9&gt;&lt;/s8&gt;&lt;/a7&gt;</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T104519Z">
        <seg>&lt;a3&gt;&lt;/a3&gt;&lt;a4&gt;&lt;/a4&gt;&lt;a5&gt;&lt;/a5&gt;L'évaluation de la définition créée cette procédure composée et l'associe au nom &lt;t6&gt;carré&lt;/t6&gt;.&lt;a7&gt;&lt;s8&gt;&lt;s9&gt;12&lt;/s9&gt;&lt;/s8&gt;&lt;/a7&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;b0&gt;Exercise 1.1.&lt;/b0&gt;  Below is a sequence of expressions.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085351Z" creationid="JC Helary" creationdate="20130707T085351Z">
        <seg>&lt;b0&gt;Exercice 1.1.&lt;/b0&gt; Voici une suite d'expressions.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;b0&gt;Exercise 1.2.&lt;/b0&gt;  Translate the following expression into prefix form</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085545Z" creationid="JC Helary" creationdate="20130707T085545Z">
        <seg>&lt;b0&gt;Exercice 1.2.&lt;/b0&gt; Traduire les expressions suivantes en notation inversée</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;b0&gt;Exercise 1.3.&lt;/b0&gt;  Define a procedure that takes three numbers as arguments and returns the sum of the squares of the two larger numbers.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085655Z" creationid="JC Helary" creationdate="20130707T085655Z">
        <seg>&lt;b0&gt;Exercice 1.3.&lt;/b0&gt; Définir une procédure qui prend trois nombres comme argument et qui retourne la somme des carrés des deux nombres les plus grands.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;b0&gt;Exercise 1.4.&lt;/b0&gt;  &lt;a1&gt;&lt;/a1&gt;&lt;a2&gt;&lt;/a2&gt;&lt;a3&gt;&lt;/a3&gt;Observe that our model of evaluation allows for combinations whose operators are compound expressions.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085745Z" creationid="JC Helary" creationdate="20130707T085745Z">
        <seg>&lt;b0&gt;Exercice 1.4.&lt;/b0&gt; &lt;a1&gt;&lt;/a1&gt;&lt;a2&gt;&lt;/a2&gt;&lt;a3&gt;&lt;/a3&gt;Observer que notre modèle d'évaluation permet les combinaisons dont les opérateurs sont des expressions composées.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;b0&gt;Exercise 1.5.&lt;/b0&gt;  &lt;a1&gt;&lt;/a1&gt;&lt;a2&gt;&lt;/a2&gt;Ben Bitdiddle has invented a test to determine whether the interpreter he is faced with is using applicative-order evaluation or normal-order evaluation.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T133226Z" creationid="JC Helary" creationdate="20130707T133226Z">
        <seg>&lt;b0&gt;Exercice 1.5.&lt;/b0&gt; &lt;a1&gt;&lt;/a1&gt;&lt;a2&gt;&lt;/a2&gt;Bernard Bitron a inventé un test pour déterminer si l'interpréteur qu'il utilise évalue selon l'ordre applicatif ou selon l'ordre normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;b0&gt;Figure 1.1:&lt;/b0&gt;  Tree representation, showing the value of each subcombination.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T125901Z">
        <seg>&lt;b0&gt;Figure 1.1 :&lt;/b0&gt; Représentation par arbre, avec la valeur de chaque sous-combinaison.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s0&gt;means of abstraction&lt;/s0&gt;, by which compound elements can be named and manipulated as units.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130514T051844Z">
        <seg>Les &lt;s0&gt;méthodes d'abstraction&lt;/s0&gt; grâce auxquelles les éléments composés peuvent être nommés et manipulés en tant qu'unités.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s0&gt;means of combination&lt;/s0&gt;, by which compound elements are built from simpler ones, and</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130514T051753Z">
        <seg>Les &lt;s0&gt;méthodes de combinaison&lt;/s0&gt; avec lesquelles les éléments composés sont créés à partir des éléments plus simples, et</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;s0&gt;primitive expressions&lt;/s0&gt;, which represent the simplest entities the language is concerned with,</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T123647Z">
        <seg>Les &lt;s0&gt;expressions primitives&lt;/s0&gt; qui représentent les entités les plus simples que le langage a à considérer,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t0&gt;Define&lt;/t0&gt; is our language's simplest means of abstraction, for it allows us to use simple names to refer to the results of compound operations, such as the &lt;t1&gt;circumference&lt;/t1&gt; computed above.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T123418Z">
        <seg>&lt;t0&gt;Define&lt;/t0&gt; est la méthode d'abstraction la plus simple de notre langage car elle nous permet d'utiliser des noms simples pour faire référence au résultat d'opérations composées, telles que la &lt;t1&gt;circonférence&lt;/t1&gt; calculée plus haut.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t1&gt;Define&lt;/t1&gt; is the only example of a special form that we have seen so far, but we will meet others shortly.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T102839Z">
        <seg>&lt;t1&gt;Define&lt;/t1&gt; est le seul exemple de forme spéciale que nous ayons vu jusqu'ici mais nous en rencontrerons d'autres bientôt.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;t2&gt;Not&lt;/t2&gt; is an ordinary procedure.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T135932Z" creationid="JC Helary" creationdate="20130706T135932Z">
        <seg>&lt;t2&gt;Not&lt;/t2&gt; est une procédure normale.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A critical aspect of a programming language is the means it provides for using &lt;a0&gt;&lt;/a0&gt;names to refer to computational objects.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130521T054324Z">
        <seg>Un aspect critique d'un langage de programmation est la méthode qu'il propose pour utiliser des &lt;a0&gt;&lt;/a0&gt;noms pour faire référence à des objets informatiques.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A powerful programming language is more than just a means for instructing a computer to perform tasks.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130514T051219Z">
        <seg>Un langage de programmation puissant est bien plus qu'un moyen de faire effectuer des tâches à un ordinateur.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A second advantage of prefix notation is that it extends in a straightforward way to allow combinations to be &lt;e0&gt;nested&lt;/e0&gt;, that is, to have combinations whose elements are themselves combinations:</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T103525Z">
        <seg>Un autre avantage de la notation inversée est qu'on peut l'étendre très facilement pour autoriser les &lt;e0&gt;emboitements&lt;/e0&gt; de combinaisons, c'est-à-dire pour avoir des combinaisons dont les éléments sont eux-mêmes des combinaisons :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>According to the description of evaluation given in section &lt;a0&gt;1.1.3&lt;/a0&gt;, the interpreter first evaluates the operator and operands and then applies the resulting procedure to the resulting arguments.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T103620Z">
        <seg>D'après la description de l'évaluation donnée dans la section &lt;a0&gt;1.1.3&lt;/a0&gt;, l'interpréteur évalue en premier l'opérateur et les opérandes puis applique la procédure résultante aux arguments résultats.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An alternative evaluation model would not evaluate the operands until their values were needed.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T103717Z">
        <seg>Un modèle alternatif d'évaluation n'évalue par les opérandes avant que leurs valeurs soient requises.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another way to write the absolute-value procedure is</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T110523Z" creationid="JC Helary" creationdate="20130706T110523Z">
        <seg>Une autre manière d'écrire la procédure valeur-absolue est</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Applicative order versus normal order</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T102926Z">
        <seg>Ordre d'application et ordre normal</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As a case in point, let us consider that, in evaluating combinations, the interpreter is itself following a procedure.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T124543Z">
        <seg>Considérons dans notre cas qu'en évaluant des combinaisons l'interpréteur suit lui aussi une procédure.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As an example of how these are used, the condition that a number &lt;e0&gt;x&lt;/e0&gt; be in the range 5 &lt; &lt;e1&gt;x&lt;/e1&gt; &lt; 10 may be expressed as</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085216Z" creationid="JC Helary" creationdate="20130707T085216Z">
        <seg>Pour voir comment utiliser ces expressions, voici une manière d'exprimer qu'un nombre &lt;e0&gt;x&lt;/e0&gt; se trouve dans l'intervalle 5 &lt; &lt;e1&gt;x&lt;/e1&gt; &lt; 10</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As another example, we can define a predicate to test whether one number is greater than or equal to another as</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085303Z" creationid="JC Helary" creationdate="20130707T085303Z">
        <seg>On peut aussi définir une proposition pour vérifier si un nombre est supérieur ou égal à un autre de la manière suivante</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As we examine things in greater detail, these simple models become inadequate and must be replaced by more refined models.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T102737Z">
        <seg>À l'examen, ces modèles simples se révèlent inadéquat et demandent leur remplacement par des modèles plus rafinés.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As we shall see in chapter 3, the general notion of the environment as providing a context in which evaluation takes place will play an important role in our understanding of program execution.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130705T071216Z">
        <seg>Comme nous le verrons au chapitre 3, la notion d'un environnement en tant que contexte dans lequel l'évaluation a lieu joue un rôle important dans notre compréhension de l'exécution d'un programme.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Assume that the sequence is to be evaluated in the order in which it is presented.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085447Z" creationid="JC Helary" creationdate="20130707T085447Z">
        <seg>Considérons que la suite est évaluée dans l'ordre dans lequel elle est présentée.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cambridge, Massachusetts     London, England</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130513T154201Z">
        <seg>Cambridge, Massachusetts     Londre, Angleterre</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compound procedures are used in exactly the same way as primitive procedures.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T110659Z">
        <seg>Les procédures composées sont utilisées exactement de la même manière que les procédures primitives.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conditional expressions are evaluated as follows.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T105614Z" creationid="JC Helary" creationdate="20130706T105614Z">
        <seg>Les expressions conditionnelles sont évaluées de la manière suivante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Contents</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130513T155128Z">
        <seg>Table des matières</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Definitions that associate names with values provide a limited means of abstraction.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T103800Z">
        <seg>Les définitions qui associent des noms à des valeurs offrent un moyen limité d'abstraction.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each combination is represented by a &lt;a3&gt;&lt;/a3&gt;node with &lt;a4&gt;&lt;/a4&gt;branches corresponding to the operator and the operands of the combination stemming from it.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T125437Z">
        <seg>Chaque combinaison est représentée par un &lt;a3&gt;&lt;/a3&gt;nœud &lt;a4&gt;&lt;/a4&gt;à partir duquel partent des branches correspondant à l'opérateur et les opérandes de la combinaison.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Evaluating this combination involves three subproblems.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T000648Z">
        <seg>L'évaluation de cette combinaison pose trois sous-problèmes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even this simple rule illustrates some important points about processes in general.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T124735Z">
        <seg>Même cette règle simple illustre quelques points importants au sujet des processus en général.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even with complex expressions, the interpreter always operates in the same basic cycle: It reads an expression from the terminal, evaluates the expression, and prints the result.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T123444Z">
        <seg>Même avec des expressions complexes, l'interpréteur fonctionne toujours selon le même cycle de base : il lit l'expression à partir du terminal, il évalue cette expression et il affiche son résultat.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every powerful language has three mechanisms for accomplishing this:</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130514T051449Z">
        <seg>Tous les langages puissants disposent de trois mécanismes pour ceci :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explain your answer.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20131003T105056Z" creationid="jchelary" creationdate="20131003T105056Z">
        <seg>Expliquez votre réponse.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expressions representing numbers may be combined with an &lt;a0&gt;&lt;/a0&gt;expression representing a &lt;a1&gt;&lt;/a1&gt;&lt;a2&gt;&lt;/a2&gt;&lt;a3&gt;&lt;/a3&gt;&lt;a4&gt;&lt;/a4&gt;&lt;a5&gt;&lt;/a5&gt;primitive procedure (such as &lt;t6&gt;+&lt;/t6&gt; or &lt;t7&gt;*&lt;/t7&gt;) to form a compound expression that represents the application of the procedure to those numbers.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T123534Z">
        <seg>Les expressions qui représentent des nombres peuvent être combinées à l'aide d'une &lt;a0&gt;&lt;/a0&gt;expressions représentant une &lt;a1&gt;&lt;/a1&gt;&lt;a2&gt;&lt;/a2&gt;&lt;a3&gt;&lt;/a3&gt;&lt;a4&gt;&lt;/a4&gt;&lt;a5&gt;&lt;/a5&gt;procédure primitive (telle que &lt;t6&gt;+&lt;/t6&gt; ou &lt;t7&gt;*&lt;/t7&gt;) pour former une expression composée qui représente l'application d'une procédure à ces nombres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Expressions such as these, formed by &lt;a0&gt;&lt;/a0&gt;delimiting a list of expressions within parentheses in order to denote &lt;a1&gt;&lt;/a1&gt;procedure application, are called &lt;e2&gt;combinations&lt;/e2&gt;.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T011328Z">
        <seg>Ces expressions, constituées en &lt;a0&gt;&lt;/a0&gt;limitant une liste d'expressions entre parenthèses de manière à indiquer &lt;a1&gt;&lt;/a1&gt;l'application d'une procédure sont appelées des &lt;e2&gt;combinaisons&lt;/e2&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, observe that the first step dictates that in order to accomplish the evaluation process for a combination we must first perform the evaluation process on each element of the combination.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T124831Z">
        <seg>En premier, il faut observer que la première étape spécifie que pour accomplir le processus d'évaluation pour une combinaison, nous devons effectuer ce processus d'évaluation sur chaque élément de la combinaison.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For compound procedures, the application process is as follows:</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130624T234234Z">
        <seg>Pour les procédures composées, le processus d'application est le suivant :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, &lt;e1&gt;x&lt;/e1&gt;&lt;s2&gt;2&lt;/s2&gt; + &lt;e3&gt;y&lt;/e3&gt;&lt;s4&gt;2&lt;/s4&gt; can be expressed as</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T110250Z">
        <seg>Par exemple, &lt;e1&gt;x&lt;/e1&gt;&lt;s2&gt;2&lt;/s2&gt; + &lt;e3&gt;y&lt;/e3&gt;&lt;s4&gt;2&lt;/s4&gt; peut être exprimé ainsi</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, evaluating</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T125141Z">
        <seg>Par exemple, l'évaluation de</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example:</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T011147Z">
        <seg>Par exemple :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, evaluating &lt;t0&gt;(define x 3)&lt;/t0&gt; does not apply &lt;t1&gt;define&lt;/t1&gt; to two arguments, one of which is the value of the symbol &lt;t2&gt;x&lt;/t2&gt; and the other of which is 3, since the purpose of the &lt;t3&gt;define&lt;/t3&gt; is precisely to associate &lt;t4&gt;x&lt;/t4&gt; with a value.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T043947Z">
        <seg>Par exemple, l'évaluation de &lt;t0&gt;(define x 3)&lt;/t0&gt; n'applique pas &lt;t1&gt;define&lt;/t1&gt; aux deux arguments dont l'un est le symbole &lt;t2&gt;x&lt;/t2&gt; et l'autre puisque la fonction de &lt;t3&gt;define &lt;/t3&gt; est précisément d'associer &lt;t4&gt;x&lt;/t4&gt; à une valeur.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, we cannot define a procedure that computes the &lt;a0&gt;&lt;/a0&gt;absolute value of a number by testing whether the number is positive, negative, or zero and taking different actions in the different cases according to the rule</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T073931Z" creationid="JC Helary" creationdate="20130706T073931Z">
        <seg>Par exemple, nous ne pouvons par définir de procédure qui calcule &lt;a0&gt;&lt;/a0&gt;la valeur absolue d'un nombre en testant si le nombre est positif, négatif ou égal à zéro et en effectuant des actions différentes selon les cas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Harold Abelson and Gerald Jay Sussman</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130513T154109Z">
        <seg>Harold Abelson et Gerald Jay Sussman</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Having defined &lt;t0&gt;square&lt;/t0&gt;, we can now use it:</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T105742Z">
        <seg>Nous avons défini &lt;t0&gt;carré&lt;/t0&gt;, nous pouvons maintenant l'utiliser :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>He defines the following two procedures:</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T133239Z" creationid="JC Helary" creationdate="20130707T133239Z">
        <seg>Il définit les deux procédures suivantes :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here are further examples of the use of &lt;t0&gt;define&lt;/t0&gt;:</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130522T151644Z">
        <seg>Voici d'autres exemples d'utilisation de &lt;t0&gt;define&lt;/t0&gt; :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is yet another way to write the absolute-value procedure:</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T111144Z" creationid="JC Helary" creationdate="20130706T111144Z">
        <seg>Voici encore une autre manière d'écrire la procédure valeur-absolue :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, there are two points that should be stressed:</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T005533Z">
        <seg>Cependant, nous devons insister sur deux points :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If &lt;&lt;e4&gt;p&lt;s5&gt;2&lt;/s5&gt;&lt;/e4&gt;&gt;'s value is also false, then &lt;&lt;e6&gt;p&lt;s7&gt;3&lt;/s7&gt;&lt;/e6&gt;&gt; is evaluated.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T105743Z" creationid="JC Helary" creationdate="20130706T105707Z">
        <seg>Si la valeur de &lt;&lt;e4&gt;p&lt;s5&gt;2&lt;/s5&gt;&lt;/e4&gt;&gt; est également fausse alors &lt;&lt;e6&gt;p&lt;s7&gt;3&lt;/s7&gt;&lt;/e6&gt;&gt; est évaluée.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If all &lt;&lt;e4&gt;e&lt;/e4&gt;&gt;'s evaluate to false, the value of the &lt;t5&gt;or&lt;/t5&gt; expression is false.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T112302Z" creationid="JC Helary" creationdate="20130706T112302Z">
        <seg>Si toutes les &lt;&lt;e4&gt;e&lt;/e4&gt;&gt; s'évaluent à faux, la valeur de l'expression &lt;t5&gt;or&lt;/t5&gt; est faux.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If all &lt;&lt;e4&gt;e&lt;/e4&gt;&gt;'s evaluate to true values, the value of the &lt;t5&gt;and&lt;/t5&gt; expression is the value of the last one.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T024216Z" creationid="JC Helary" creationdate="20130706T112147Z">
        <seg>Si toutes les &lt;&lt;e4&gt;e&lt;/e4&gt;&gt; s'évaluent à des valeurs vraies, la valeur de l'expression &lt;t5&gt;and&lt;/t5&gt; est la valeur de la dernière.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any &lt;&lt;e1&gt;e&lt;/e1&gt;&gt; evaluates to a true value, that value is returned as the value of the &lt;t2&gt;or&lt;/t2&gt; expression, and the rest of the &lt;&lt;e3&gt;e&lt;/e3&gt;&gt;'s are not evaluated.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T024231Z" creationid="JC Helary" creationdate="20130706T112241Z">
        <seg>Si une &lt;&lt;e1&gt;e&lt;/e1&gt;&gt; s'évalue à une valeur vrai, cette valeur est retournée en tant que valeur de l'expression &lt;t2&gt;or&lt;/t2&gt; et le reste des &lt;&lt;e3&gt;e&lt;/e3&gt;&gt; ne sont pas évaluées.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any &lt;&lt;e1&gt;e&lt;/e1&gt;&gt; evaluates to false, the value of the &lt;t2&gt;and&lt;/t2&gt; expression is false, and the rest of the &lt;&lt;e3&gt;e&lt;/e3&gt;&gt;'s are not evaluated.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T112047Z" creationid="JC Helary" creationdate="20130706T112047Z">
        <seg>Si une &lt;&lt;e1&gt;e&lt;/e1&gt;&gt; s'évalue à faux, la valeur de l'expression &lt;t2&gt;and&lt;/t2&gt; est fausse et le reste des &lt;&lt;e3&gt;e&lt;/e3&gt;&gt; ne sont pas évaluées.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If its value is false, then &lt;&lt;e2&gt;p&lt;s3&gt;2&lt;/s3&gt;&lt;/e2&gt;&gt; is evaluated.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T105659Z" creationid="JC Helary" creationdate="20130706T105659Z">
        <seg>Si sa valeur est fausse alors &lt;&lt;e2&gt;p&lt;s3&gt;2&lt;/s3&gt;&lt;/e2&gt;&gt; est évalué.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If none of the &lt;&lt;e11&gt;p&lt;/e11&gt;&gt;'s is found to be true, the value of the &lt;t12&gt;cond&lt;/t12&gt; is undefined.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T024144Z" creationid="JC Helary" creationdate="20130706T110130Z">
        <seg>Si aucune des &lt;&lt;e11&gt;p&lt;/e11&gt;&gt; n'est vraie alors la valeur de &lt;t12&gt;cond&lt;/t12&gt; est indéfinie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;&lt;e3&gt;predicate&lt;/e3&gt;&gt; evaluates to a true value, the interpreter then evaluates the &lt;a4&gt;&lt;/a4&gt;&lt;&lt;e5&gt;consequent&lt;/e5&gt;&gt; and returns its value.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T024031Z" creationid="JC Helary" creationdate="20130706T111525Z">
        <seg>Si la &lt;&lt;e3&gt;proposition&lt;/e3&gt;&gt; s'évalue à une valeur vraie alors l'interpréteur évalue la &lt;a4&gt;&lt;/a4&gt;&lt;&lt;e5&gt;conséquence&lt;/e5&gt;&gt; et retourne sa valeur.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If we use the definition of &lt;t0&gt;square&lt;/t0&gt;, this reduces to</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T001105Z">
        <seg>Si nous utilisons la définition de &lt;t0&gt;carré&lt;/t0&gt;, nous réduisons ceci à</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If we used this method, the evaluation of</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T105759Z">
        <seg>Avec cette méthode, l'évaluation de</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Imagine that you are sitting at a computer terminal.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130514T063819Z">
        <seg>Imaginez-vous assis devant un ordinateur.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to primitive predicates such as &lt;t0&gt;&lt;&lt;/t0&gt;, &lt;t1&gt;=&lt;/t1&gt;, and &lt;t2&gt;&gt;&lt;/t2&gt;, there are logical composition operations, which enable us to construct compound predicates.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T024049Z" creationid="JC Helary" creationdate="20130706T111858Z">
        <seg>En plus des propositions primitives tels que &lt;t0&gt;&lt;&lt;/t0&gt;, &lt;t1&gt;=&lt;/t1&gt; et &lt;t2&gt;&gt;&lt;/t2&gt;, il existe des opérations de composition logiques qui nous permettent de construire des propositions composées.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In an interactive language such as Lisp, it is meaningless to speak of the value of an expression such as &lt;t3&gt;(+ x 1)&lt;/t3&gt; without specifying any information about the environment that would provide a meaning for the symbol &lt;t4&gt;x&lt;/t4&gt; (or even for the symbol &lt;t5&gt;+&lt;/t5&gt;).</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T043559Z">
        <seg>Dans un langage interactif tel que Lisp, parler de la valeur d'une expression telle que &lt;t3&gt;(+ x 1)&lt;/t3&gt; sans donner d'information au sujet de l'environnement qui définisse le symbole &lt;t4&gt;x&lt;/t4&gt; (ou même le symbole &lt;t5&gt;+&lt;/t5&gt;) n'a pas de sens.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In comparison with most other programming languages, Lisp has a very simple syntax; that is, the evaluation rule for expressions can be described by a simple general rule together with specialized rules for a small number of special forms.&lt;a4&gt;&lt;s5&gt;&lt;s6&gt;11&lt;/s6&gt;&lt;/s5&gt;&lt;/a4&gt;</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T103226Z">
        <seg>Comparé à d'autres langages de programmation, Lisp a une syntaxe très simple ; la règle d'évaluation des expressions peut être décrite à l'aide d'une règle générale simple et de règles spéciales pour un petit nombre de formes spéciales.&lt;a4&gt;&lt;s5&gt;&lt;s6&gt;11&lt;/s6&gt;&lt;/s5&gt;&lt;/a4&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, any expression that always evaluates to a true value could be used as the &lt;&lt;e9&gt;p&lt;/e9&gt;&gt; here.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T024200Z" creationid="JC Helary" creationdate="20130706T111133Z">
        <seg>En fait, toute expression qui s'évalue toujours à une valeur vraie peut être utilisée en tant que &lt;&lt;e9&gt;p&lt;/e9&gt;&gt; ici.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, the ``percolate values upward'' form of the evaluation rule is an example of a general kind of process known as &lt;a6&gt;&lt;/a6&gt;&lt;e7&gt;tree accumulation&lt;/e7&gt;.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T125834Z">
        <seg>De fait, la « remontée des valeurs vers le haut » lors de l'évaluation est un exemple d'un type général de processus connu sous le nom de &lt;a6&gt;&lt;/a6&gt;accumulation ***&lt;e7&gt;&lt;/e7&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, computational objects may have very complex structures, and it would be extremely inconvenient to have to remember and repeat their details each time we want to use them.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130613T054110Z">
        <seg>En général, les objets informatiques peuvent avoir des structures très complexes et il serait très peu pratique d'avoir à se souvenir et à reproduire leurs détails à chaque fois que nous voulons les utiliser.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, we shall see that recursion is a very powerful technique for dealing with hierarchical, treelike objects.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T125718Z">
        <seg>D'une manière générale, nous verrons que la récursion est une technique très puissante pour traiter des objets hiérarchiques sous formes d'arbres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, when &lt;a0&gt;&lt;/a0&gt;modeling phenomena in science and engineering, we begin with simplified, incomplete models.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T103441Z">
        <seg>En général, quand &lt;a0&gt;&lt;/a0&gt; on modélise des phénomènes en sciences ou en ingénierie, on commence par des modèles simples et incomplets.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, the evaluations of &lt;t0&gt;(+ 5 1)&lt;/t0&gt; and &lt;t1&gt;(* 5 2)&lt;/t1&gt; are each performed twice here, corresponding to the reduction of the expression</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T110122Z">
        <seg>En particulier, les évaluations de &lt;t0&gt;(+ 5 1)&lt;/t0&gt; et &lt;t1&gt;(* 5 2)&lt;/t1&gt; sont effectuées deux fois lors de la réduction de l'expression</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In particular, when we address in chapter 3 the use of procedures with ``mutable data,'' we will see that the substitution model breaks down and must be replaced by a more complicated model of procedure application.&lt;a1&gt;&lt;s2&gt;&lt;s3&gt;15&lt;/s3&gt;&lt;/s2&gt;&lt;/a1&gt;</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T103427Z">
        <seg>En particulier, quand nous aborderons l'utilisation des procédures avec des « données mutables » au chapitre 3, nous verrons que le modèle de substitution ne fonctionne plus et doit être remplacé par un modèle plus complexe d'application de procédure.&lt;a1&gt;&lt;s2&gt;&lt;s3&gt;15&lt;/s3&gt;&lt;/s2&gt;&lt;/a1&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In practice, the ``substitution'' is accomplished by using a local environment for the formal parameters.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T103518Z">
        <seg>En pratique, la « substitution » est accomplie en utilisant un environnent local pour les paramètres formels.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In programming, we deal with two kinds of elements:</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="Didier" changedate="20130528T134225Z">
        <seg>In programming, we deal with two kinds of elements:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In programming, we deal with two kinds of elements: &lt;a0&gt;&lt;/a0&gt;procedures and &lt;a1&gt;&lt;/a1&gt;data.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T123623Z">
        <seg>La programmation travaille sur deux types d'éléments : &lt;a0&gt;&lt;/a0&gt;les procédures et &lt;a1&gt;&lt;/a1&gt;les données.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the Scheme dialect of Lisp, we name things with &lt;a0&gt;&lt;/a0&gt;&lt;a1&gt;&lt;/a1&gt;&lt;t2&gt;define&lt;/t2&gt;.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130522T151434Z">
        <seg>Dans le dialecte de Lisp, Scheme, les choses sont nommés à l'aide de &lt;a0&gt;&lt;/a0&gt;&lt;a1&gt;&lt;/a1&gt;&lt;t2&gt;define&lt;/t2&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this chapter we will deal only with simple &lt;a0&gt;&lt;/a0&gt;&lt;a1&gt;&lt;/a1&gt;numerical data so that we can focus on the rules for building procedures.&lt;a2&gt;&lt;s3&gt;&lt;s4&gt;4&lt;/s4&gt;&lt;/s3&gt;&lt;/a2&gt; In later chapters we will see that these same rules allow us to build procedures to manipulate compound data as well.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T123611Z">
        <seg>Dans ce chapitre nous nous intéresserons à des &lt;a0&gt;&lt;/a0&gt;&lt;a1&gt;&lt;/a1&gt;données numériques simples de manière à nous concentrer sur les règles de création des procédures.&lt;a2&gt;&lt;s3&gt;&lt;s4&gt;4&lt;/s4&gt;&lt;/s3&gt;&lt;/a2&gt; Dans les chapitres suivants nous verrons que les mêmes règles nous permettent de créer des procédures pour manipuler également des données composites.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indeed, complex programs are constructed by building, step by step, computational objects of increasing complexity.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T123405Z">
        <seg>En fait, les programmes complexes sont construits en créant pas à pas des objets informatiques de complexité croissante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indeed, one could not tell by looking at the definition of &lt;t0&gt;sum-of-squares&lt;/t0&gt; given above whether &lt;t1&gt;square&lt;/t1&gt; was built into the interpreter, like &lt;t2&gt;+&lt;/t2&gt; and &lt;t3&gt;*&lt;/t3&gt;, or defined as a compound procedure.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T110833Z">
        <seg>En fait, il est impossible de dire en regardant la définition de &lt;t0&gt;somme-de-carrés&lt;/t0&gt; donnée plus haut si &lt;t1&gt;carré&lt;/t1&gt; est inclus dans l'interpréteur comme &lt;t2&gt;+&lt;/t2&gt; et &lt;t3&gt;*&lt;/t3&gt; ou défini en tant que procédure composée.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead it would first substitute operand expressions for parameters until it obtained an expression involving only primitive operators, and would then perform the evaluation.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T103854Z">
        <seg>Il substituerait plutôt les expressions d'opérandes par des paramètres jusqu'à ce qu'il obtienne une expression qui ne contienne que des opérateurs primitifs et effectuerait alors l'évaluation.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be shown that, for procedure applications that can be modeled using substitution (including all the procedures in the first two chapters of this book) and that yield legitimate values, normal-order and applicative-order evaluation produce the same value.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T110646Z">
        <seg>On peut montrer que pour l'application de procédures qui peuvent être modélisées à l'aide de la substitution (toutes les procédures dans les deux premiers chapitres de ce livre) et qui produisent des valeurs légitimes, l'évaluation en ordre normal et en ordre d'application produisent les mêmes valeurs.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be taken as a model that determines the ``meaning'' of procedure application, insofar as the procedures in this chapter are concerned.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T005520Z">
        <seg>Il peut être considéré comme un modèle qui détermine la « signification » de l'application de procédure dans le cadre des procédures de ce chapitre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is called &lt;a1&gt;&lt;/a1&gt;&lt;a2&gt;&lt;/a2&gt;&lt;a3&gt;&lt;/a3&gt;&lt;t4&gt;cond&lt;/t4&gt; (which stands for ``conditional''), and it is used as follows:</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T105315Z" creationid="JC Helary" creationdate="20130706T105315Z">
        <seg>Cette forme se nomme &lt;a1&gt;&lt;/a1&gt;&lt;a2&gt;&lt;/a2&gt;&lt;a3&gt;&lt;/a3&gt;&lt;t4&gt;cond&lt;/t4&gt; (pour « condition ») et elle et utilisée de la manière suivante :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is we humans who get confused by still relatively simple expressions such as</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T085129Z">
        <seg>Ce sont nous, les humains, qui sont perplexes face à une expression relativement simple du type</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It should be clear that the possibility of associating values with symbols and later retrieving them means that the interpreter must maintain some sort of memory that keeps track of the name-object pairs.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T124216Z">
        <seg>Il est clair que la possibilité d'associer des valeurs à des symboles puis de les retrouver par la suite signifie que l'interpréteur doit entretenir une mémoire qui enregistre les paires nom-objet.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lisp uses applicative-order evaluation, partly because of the additional efficiency obtained from avoiding multiple evaluations of expressions such as those illustrated with &lt;t0&gt;(+ 5 1)&lt;/t0&gt; and &lt;t1&gt;(* 5 2)&lt;/t1&gt; above and, more significantly, because normal-order evaluation becomes much more complicated to deal with when we leave the realm of procedures that can be modeled by substitution.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T131643Z">
        <seg>Lisp utilise l'évaluation en ordre d'application en partie à cause de l'efficacité supplémentaire obtenue en évitant les évaluations multiples d'expressions telles que celles illustrées avec &lt;t0&gt;(+ 5 1)&lt;/t0&gt; et &lt;t1&gt;(* 5 2)&lt;/t1&gt; ci-dessus, et surtout car l'évaluation en ordre normal devient bien plus compliquée à pratiquer quand on quitte le domaine des procédures qui peuvent être modélisées par substitution.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>McGraw-Hill Book Company</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130513T154205Z">
        <seg>McGraw-Hill Book Company</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nesting of combinations provides a means of combining operations.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T103651Z">
        <seg>L'emboitement de combinaisons offre une manière de combiner les opérations.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New York     St. Louis     San Francisco     Montreal     Toronto</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130513T154223Z">
        <seg>New York     St. Louis     San Francisco     Montréal     Toronto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, observe that the repeated application of the first step brings us to the point where we need to evaluate, not combinations, but primitive expressions such as numerals, built-in operators, or other names.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T130127Z">
        <seg>Ensuite, il faut comprendre que l'application répétée de la première étape nous amène au point où nous devons évaluer non pas des combinaisons mais des expressions primitives telles que des numéraux, des opérateurs *** et d'autres noms.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No ambiguity can arise, because the operator is always the leftmost element and the entire combination is delimited by the parentheses.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T123503Z">
        <seg>Il n'y a aucune ambiguïté car l'opérateur est l'élément le plus à gauche et la combinaison entière est délimitée par des parenthèses.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice how succinctly the idea of recursion can be used to express what, in the case of a deeply nested combination, would otherwise be viewed as a rather complicated process.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T103617Z">
        <seg>Remarquez la manière succincte avec laquelle l'idée de récursion peut être utilisée pour exprimer ce qui, dans le cas de combinaisons profondément emboitées, serait considéré comme un processus plutôt complexe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that &lt;t0&gt;and&lt;/t0&gt; and &lt;t1&gt;or&lt;/t1&gt; are special forms, not procedures, because the subexpressions are not necessarily all evaluated.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T135913Z" creationid="JC Helary" creationdate="20130706T135913Z">
        <seg>Remarquez que &lt;t0&gt;and&lt;/t0&gt; et &lt;t1&gt;or&lt;/t1&gt; sont des formes spéciales, pas des procédures, car leurs sous-expressions ne sont pas nécessairement toutes évaluées.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice that the evaluation rule given above does not handle definitions.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T043730Z">
        <seg>Remarquez que la règle d'évaluation ci-dessus ne prend pas en compte les définitions.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now &lt;t1&gt;(+ 5 1)&lt;/t1&gt; produces 6 and &lt;t2&gt;(* 5 2)&lt;/t2&gt; produces 10, so we must apply the &lt;t3&gt;sum-of-squares&lt;/t3&gt; procedure to 6 and 10.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T000919Z">
        <seg>&lt;t1&gt;(+ 5 1)&lt;/t1&gt; vaut 6 et &lt;t2&gt;(* 5 2)&lt;/t2&gt; vaut 10. Nous devons donc appliquer la procédure &lt;t3&gt;somme-de-carrés&lt;/t3&gt; à 6 et 10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now we can use &lt;t0&gt;sum-of-squares&lt;/t0&gt; as a building block in constructing further procedures:</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T110611Z">
        <seg>Nous pouvons utiliser &lt;t0&gt;somme-de-carrés&lt;/t0&gt; comme bloc pour construire d'autres procédures :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now we will learn about &lt;a0&gt;&lt;/a0&gt;&lt;e1&gt;procedure definitions&lt;/e1&gt;, a much more powerful abstraction technique by which a compound operation can be given a name and then referred to as a unit.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T104028Z">
        <seg>Nous allons maintenant voir les &lt;a0&gt;&lt;/a0&gt;&lt;e1&gt;définitions de procédures&lt;/e1&gt;, une technique d'abstraction bien plus puissante avec laquelle on peut nommer une opération composée puis faire référence à celle-ci en tant que tout.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Numbers and arithmetic operations are primitive data and procedures.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T103452Z">
        <seg>Les nombres et les opérations arithmétiques sont respectivement des données et procédures primitives.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Observe in particular that it is not necessary to explicitly instruct the interpreter to print the value of the expression.&lt;a3&gt;&lt;s4&gt;&lt;s5&gt;7&lt;/s5&gt;&lt;/s4&gt;&lt;/a3&gt;</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130521T053227Z">
        <seg>On observera qu'il n'est pas nécessaire de demander explicitement à l'interpréteur d'afficher la valeur de l'expression.&lt;a3&gt;&lt;s4&gt;&lt;s5&gt;7&lt;/s5&gt;&lt;/s4&gt;&lt;/a3&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, normal-order evaluation can be an extremely valuable tool, and we will investigate some of its implications in chapters 3 and 4.&lt;a2&gt;&lt;s3&gt;&lt;s4&gt;16&lt;/s4&gt;&lt;/s3&gt;&lt;/a2&gt;</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T111629Z">
        <seg>Cependant, l'évaluation en ordre normal peut être un outil précieux et nous étudierons certaines de ses implications dans les chapitres 3 et 4.&lt;a2&gt;&lt;s3&gt;&lt;s4&gt;16&lt;/s4&gt;&lt;/s3&gt;&lt;/a2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One easy way to get started at programming is to examine some typical interactions with an interpreter for the Scheme dialect of Lisp.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T123601Z">
        <seg>Une manière facile de commencer la programmation est d'examiner des interactions à l'aide d'un interpréteur pour le dialecte de Lisp qu'est Scheme.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One kind of primitive expression you might type is a number.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T010725Z">
        <seg>Un type d'expression primitive qu'il est possible de saisir est un nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of our goals in this chapter is to isolate issues about thinking procedurally.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T124450Z">
        <seg>Un de nos objectifs dans ce chapitre est d'isoler les questions relatives à la pensée procédurale.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of them is that it can accommodate &lt;a2&gt;&lt;/a2&gt;&lt;a3&gt;&lt;/a3&gt;procedures that may take an arbitrary number of arguments, as in the following examples:</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T123512Z">
        <seg>L'un d'entre eux est de s'accommoder de &lt;a2&gt;&lt;/a2&gt;&lt;a3&gt;&lt;/a3&gt;procédures qui ont un nombre quelconque d'arguments comme dans les exemples suivants :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise it evaluates the &lt;a6&gt;&lt;/a6&gt;&lt;&lt;e7&gt;alternative&lt;/e7&gt;&gt; and returns its value.&lt;a8&gt;&lt;s9&gt;&lt;s10&gt;19&lt;/s10&gt;&lt;/s9&gt;&lt;/a8&gt;</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T111744Z" creationid="JC Helary" creationdate="20130706T111548Z">
        <seg>Autrement il évalue l'&lt;a6&gt;&lt;/a6&gt;&lt;&lt;e7&gt;alternative&lt;/e7&gt;&gt; et retourne sa valeur.&lt;a8&gt;&lt;s9&gt;&lt;s10&gt;19&lt;/s10&gt;&lt;/s9&gt;&lt;/a8&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Over the course of this book, we will present a sequence of increasingly elaborate models of how interpreters work, culminating with a complete implementation of an interpreter and compiler in chapter 5.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T102151Z">
        <seg>Au cours de cet ouvrage, nous présenterons une suite de modèles de fonctionnement de l'interpréteur de complexité croissante qui culminera avec l'implémentation complète d'un interpréteur et d'un compilateur au chapitre 5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prefix notation has several advantages, however.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T045717Z">
        <seg>La notation inversée a cependant plusieurs avantages.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structure and Interpretation</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130513T154055Z">
        <seg>Structure et interprétation</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Structure and Interpretation of Computer Programs</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130608T144623Z">
        <seg>Structure et interprétation des programmes informatiques</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such exceptions to the general evaluation rule are called &lt;e0&gt;special forms&lt;/e0&gt;.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T102708Z">
        <seg>Ce genre d'exceptions à la règle générale d'évaluation sont appelées des &lt;e0&gt;formes spéciales&lt;/e0&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the interpreter evaluates the elements of the combination and applies the procedure (which is the value of the operator of the combination) to the arguments (which are the values of the operands of the combination).</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130624T232416Z">
        <seg>L'interpréteur évalue les éléments de la combinaison et applique la procédure (qui est la valeur de l'opérateur de la combinaison) aux arguments (qui sont les valeurs des opérandes de la combinaison).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;&lt;e0&gt;name&lt;/e0&gt;&gt; is a symbol to be associated with the procedure definition in the environment.&lt;a1&gt;&lt;s2&gt;&lt;s3&gt;13&lt;/s3&gt;&lt;/s2&gt;&lt;/a1&gt; The &lt;a4&gt;&lt;/a4&gt;&lt;a5&gt;&lt;/a5&gt;&lt;&lt;e6&gt;formal parameters&lt;/e6&gt;&gt; are the names used within the body of the procedure to refer to the corresponding arguments of the procedure.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T104741Z">
        <seg>Le &lt;&lt;e0&gt;nom&lt;/e0&gt;&gt; est un symbole à associer à la définition de procédure dans l'environnement.&lt;a1&gt;&lt;s2&gt;&lt;s3&gt;13&lt;/s3&gt;&lt;/s2&gt;&lt;/a1&gt; Les &lt;a4&gt;&lt;/a4&gt;&lt;a5&gt;&lt;/a5&gt;&lt;&lt;e6&gt;paramètres formels&lt;/e6&gt;&gt; sont les noms utilisés dans le corps de la procédure pour faire référence aux arguments correspondants de la procédure.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;a5&gt;&lt;/a5&gt;terminal nodes (that is, nodes with no branches stemming from them) represent either operators or numbers.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T125522Z">
        <seg>Les &lt;a5&gt;&lt;/a5&gt;nœuds terminaux (c'est-à-dire les nœuds dont ne partent aucune branche) représentent soit des opérateurs, soit des nombres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;a7&gt;&lt;/a7&gt;&lt;a8&gt;&lt;/a8&gt;&lt;&lt;e9&gt;body&lt;/e9&gt;&gt; is an expression that will yield the value of the procedure application when the formal parameters are replaced by the actual arguments to which the procedure is applied.&lt;a10&gt;&lt;s11&gt;&lt;s12&gt;14&lt;/s12&gt;&lt;/s11&gt;&lt;/a10&gt; The &lt;&lt;e13&gt;name&lt;/e13&gt;&gt; and the &lt;&lt;e14&gt;formal parameters&lt;/e14&gt;&gt; are grouped within &lt;a15&gt;&lt;/a15&gt;parentheses, just as they would be in an actual call to the procedure being defined.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T105021Z">
        <seg>Le &lt;a7&gt;&lt;/a7&gt;&lt;a8&gt;&lt;/a8&gt;&lt;&lt;e9&gt;corps&lt;/e9&gt;&gt; est une expression qui produira la valeur de l'application de la procédure quand les paramètres formels sont remplacés par les arguments actuels sur lesquels la procédure va s'appliquer.&lt;a10&gt;&lt;s11&gt;&lt;s12&gt;14&lt;/s12&gt;&lt;/s11&gt;&lt;/a10&gt; Le &lt;&lt;e13&gt;nom&lt;/e13&gt;&gt; et les &lt;&lt;e14&gt;paramètres formels&lt;/e14&gt;&gt; sont regroupés entre &lt;a15&gt;&lt;/a15&gt;parenthèses, de la même manière que si la fonction définie était réellement appelée.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;a7&gt;&lt;/a7&gt;value of a combination is obtained by applying the procedure specified by the operator to the &lt;a8&gt;&lt;/a8&gt;&lt;e9&gt;arguments&lt;/e9&gt; that are the values of the operands.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T123525Z">
        <seg>La &lt;a7&gt;&lt;/a7&gt;valeur de la combinaison est obtenue en appliquant la procédure spécifiée par l'opérateur aux &lt;a8&gt;&lt;/a8&gt;&lt;e9&gt;arguments&lt;/e9&gt; qui sont les valeurs des opérandes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The MIT Press</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130513T154208Z">
        <seg>The MIT Press</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The absolute-value procedure &lt;t1&gt;abs&lt;/t1&gt; makes use of the &lt;a2&gt;&lt;/a2&gt;&lt;a3&gt;&lt;/a3&gt;&lt;a4&gt;&lt;/a4&gt;&lt;a5&gt;&lt;/a5&gt;&lt;a6&gt;&lt;/a6&gt;&lt;a7&gt;&lt;/a7&gt;&lt;a8&gt;&lt;/a8&gt;&lt;a9&gt;&lt;/a9&gt;&lt;a10&gt;&lt;/a10&gt;primitive predicates &lt;t11&gt;&gt;&lt;/t11&gt;, &lt;t12&gt;&lt;&lt;/t12&gt;, and &lt;t13&gt;=&lt;/t13&gt;.&lt;a14&gt;&lt;s15&gt;&lt;s16&gt;18&lt;/s16&gt;&lt;/s15&gt;&lt;/a14&gt; These take two numbers as arguments and test whether the first number is, respectively, greater than, less than, or equal to the second number, returning true or false accordingly.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T023943Z" creationid="JC Helary" creationdate="20130706T110458Z">
        <seg>La procédure valeur-absolue &lt;t1&gt;abs&lt;/t1&gt; utilise les &lt;a2&gt;&lt;/a2&gt;&lt;a3&gt;&lt;/a3&gt;&lt;a4&gt;&lt;/a4&gt;&lt;a5&gt;&lt;/a5&gt;&lt;a6&gt;&lt;/a6&gt;&lt;a7&gt;&lt;/a7&gt;&lt;a8&gt;&lt;/a8&gt;&lt;a9&gt;&lt;/a9&gt;&lt;a10&gt;&lt;/a10&gt;propositions primitives &lt;t11&gt;&gt;&lt;/t11&gt;, &lt;t12&gt;&lt;&lt;/t12&gt; et &lt;t13&gt;=&lt;/t13&gt;.&lt;a14&gt;&lt;s15&gt;&lt;s16&gt;18&lt;/s16&gt;&lt;/s15&gt;&lt;/a14&gt; Ces propositions requièrent deux nombres comme arguments et vérifient si le premier nombre est respectivement supérieur, inférieur ou égal au second nombre, retournant vrai ou faux selon les cas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The convention of placing the operator to the left of the operands is known as &lt;a0&gt;&lt;/a0&gt;&lt;e1&gt;prefix notation&lt;/e1&gt;, and it may be somewhat confusing at first because it departs significantly from the customary mathematical convention.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T045654Z">
        <seg>La convention qui consiste à placer l'opérateur à la gauche des opérandes est connue sous le nom de &lt;a0&gt;&lt;/a0&gt;&lt;e1&gt;notation inversée&lt;/e1&gt; et peut prêter à confusion au début car elle est très différente des conventions utilisées d'habitude en mathématiques.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expressive power of the class of procedures that we can define at this point is very limited, because we have no way to make tests and to perform different operations depending on the result of a test.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T073819Z" creationid="JC Helary" creationdate="20130706T073819Z">
        <seg>Le pouvoir expressif de la classe de procédures que nous avons pu définir jusqu'ici est très limité car nous n'avons aucun moyen d'effectuer des tests et des opérations en fonction du résultat des tests.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first expression in each pair is a &lt;a8&gt;&lt;/a8&gt;&lt;e9&gt;predicate&lt;/e9&gt; -- that is, an expression whose value is interpreted as either true or false.&lt;a10&gt;&lt;s11&gt;&lt;s12&gt;17&lt;/s12&gt;&lt;/s11&gt;&lt;/a10&gt;</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T023624Z" creationid="JC Helary" creationdate="20130706T105555Z">
        <seg>La première expression dans chaque paire est une &lt;a8&gt;&lt;/a8&gt;&lt;e9&gt;proposition&lt;/e9&gt; -- c'est-à-dire une expression qui est soit vraie soit fausse.&lt;a10&gt;&lt;s11&gt;&lt;s12&gt;17&lt;/s12&gt;&lt;/s11&gt;&lt;/a10&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The general form of a conditional expression is</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T105337Z" creationid="JC Helary" creationdate="20130706T105337Z">
        <seg>La forme générale d'une expression conditionnelle est</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The general form of a procedure definition is</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T104534Z">
        <seg>La forme générale d'une définition de procédure est</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The general form of an &lt;t2&gt;if&lt;/t2&gt; expression is</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T111249Z" creationid="JC Helary" creationdate="20130706T111249Z">
        <seg>La forme générale d'une expression &lt;t2&gt;if&lt;/t2&gt; est</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interpreter evaluates the expressions &lt;&lt;e0&gt;e&lt;/e0&gt;&gt; one at a time, in left-to-right order.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T111949Z" creationid="JC Helary" creationdate="20130706T111949Z">
        <seg>L'interprète évalue les expressions &lt;&lt;e0&gt;e&lt;/e0&gt;&gt; une par une, de gauche à droite.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The interpreter makes this step-by-step program construction particularly convenient because name-object associations can be created incrementally in successive interactions.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T123819Z">
        <seg>L'interpréteur rend cette construction de programme par étape particulièrement pratique car les associations noms-objets peuvent être créées de manière incrémentées en interactions successives.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The language also serves as a framework within which we organize our ideas about processes.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130514T051247Z">
        <seg>Le langage est également un cadre dans lequel nous organisons nos idées et processus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The leftmost element in the list is called the &lt;a3&gt;&lt;/a3&gt;&lt;e4&gt;operator&lt;/e4&gt;, and the other elements are called &lt;a5&gt;&lt;/a5&gt;&lt;e6&gt;operands&lt;/e6&gt;.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T011427Z">
        <seg>L'élément le plus à gauche de la liste est appelé l'&lt;a3&gt;&lt;/a3&gt;&lt;e4&gt;opérateur&lt;/e4&gt; et les autres éléments sont appelés les &lt;a5&gt;&lt;/a5&gt;&lt;e6&gt;opérandes&lt;/e6&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The predicate &lt;&lt;e0&gt;p&lt;s1&gt;1&lt;/s1&gt;&lt;/e0&gt;&gt; is evaluated first.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T023632Z" creationid="JC Helary" creationdate="20130706T105642Z">
        <seg>La proposition &lt;&lt;e0&gt;p&lt;s1&gt;1&lt;/s1&gt;&lt;/e0&gt;&gt; est évaluée en premier.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The procedure represents the operation of multiplying something by itself.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T104358Z">
        <seg>La procédure représente l'opération qui consiste à multiplier une chose par elle même.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The process we have just described is called the &lt;e0&gt;substitution model&lt;/e0&gt; for procedure application.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T001157Z">
        <seg>Le processus que nous venons de décrire est appelé le &lt;e0&gt;modèle de substitution&lt;/e0&gt; pour l'application de procédures.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The purpose of the substitution is to help us think about procedure application, not to provide a description of how the interpreter really works.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T101757Z">
        <seg>L'objectif de la substitution est de nous aider à penser à l'application de la procédure et non pas de nous fournir une description du fonctionnement réel de l'interpréteur.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The resulting indentations display clearly the structure of the expression.&lt;a2&gt;&lt;s3&gt;&lt;s4&gt;6&lt;/s4&gt;&lt;/s3&gt;&lt;/a2&gt;</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130521T050523Z">
        <seg>Les indentations résultantes affichent clairement la structure de l'expression.&lt;a2&gt;&lt;s3&gt;&lt;s4&gt;6&lt;/s4&gt;&lt;/s3&gt;&lt;/a2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The substitution model is no exception.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T102749Z">
        <seg>Le modèle de substitution ne fait pas exception.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The substitution model is only the first of these models -- a way to get started thinking formally about the evaluation process.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T102233Z">
        <seg>Le modèle de substitution est seulement le premier de ces modèles, une manière de commencer à penser de manière formelle au processus d'évaluation.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The thing to be multiplied is given a local name, &lt;t2&gt;x&lt;/t2&gt;, which plays the same role that a pronoun plays in natural language.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T104437Z">
        <seg>La chose à multiplier a un nom local, &lt;t2&gt;x&lt;/t2&gt;, qui joue le même rôle qu'un pronom jouerai dans une langue naturelle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The three most frequently used are these:</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T111915Z" creationid="JC Helary" creationdate="20130706T111915Z">
        <seg>Les trois plus fréquents sont :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value of a &lt;t0&gt;not&lt;/t0&gt; expression is true when the expression &lt;&lt;e1&gt;e&lt;/e1&gt;&gt; evaluates to false, and false otherwise.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T135728Z" creationid="JC Helary" creationdate="20130706T135728Z">
        <seg>La valeur d'une expression &lt;t0&gt;not&lt;/t0&gt; est vraie quand l'expression &lt;&lt;e1&gt;e&lt;/e1&gt;&gt; est fausse, et fausse autrement.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The various kinds of expressions (each with its associated evaluation rule) constitute the &lt;a3&gt;&lt;/a3&gt;syntax of the programming language.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T103043Z">
        <seg>Les différents types d'expressions (chacun associé à une règle d'évaluation) constituent la &lt;a3&gt;&lt;/a3&gt;syntaxe du langage de programmation.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The word &lt;e0&gt;predicate&lt;/e0&gt; is used for procedures that return true or false, as well as for expressions that evaluate to true or false.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T023917Z" creationid="JC Helary" creationdate="20130706T110213Z">
        <seg>Le mot &lt;e0&gt;proposition&lt;/e0&gt; est utilisé pour des procédures qui retournent vrai ou faux ainsi que pour des expressions qui s'évaluent à vrai ou faux.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then he evaluates the expression</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T133252Z" creationid="JC Helary" creationdate="20130707T133252Z">
        <seg>Puis évalue l'expression</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then we replace the formal parameter &lt;t0&gt;a&lt;/t0&gt; by the argument 5:</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130624T234427Z">
        <seg>Puis remplaçons le paramètre formel &lt;t0&gt;a&lt;/t0&gt; par l'argument 5 :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Lisp interpreter can evaluate.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T103543Z">
        <seg>Il n'y a aucune limite (en principe) à la profondeur de ce genre d'emboitement ou à la complexité globale de l'expression que l'interpréteur Lisp peut évaluer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These values are substituted for the formal parameters &lt;t4&gt;x&lt;/t4&gt; and &lt;t5&gt;y&lt;/t5&gt; in the body of &lt;t6&gt;sum-of-squares&lt;/t6&gt;, reducing the expression to</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T001023Z">
        <seg>Ces values sont substituées aux paramètres formels &lt;t4&gt;x&lt;/t4&gt; et &lt;t5&gt;y&lt;/t5&gt; dans le corps de &lt;t6&gt;somme-de-carrés&lt;/t6&gt; pour réduire l'expression à</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This alternative ``fully expand and then reduce'' evaluation method is known as &lt;a0&gt;&lt;/a0&gt;&lt;e1&gt;normal-order evaluation&lt;/e1&gt;, in contrast to the ``evaluate the arguments and then apply'' method that the interpreter actually uses, which is called &lt;a2&gt;&lt;/a2&gt;&lt;e3&gt;applicative-order evaluation&lt;/e3&gt;.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T110435Z">
        <seg>Cette méthode d'évaluation où l'on « développe totalement avant de réduire » est connue sous le nome de &lt;a0&gt;&lt;/a0&gt;&lt;e1&gt;évaluation en ordre normal&lt;/e1&gt;, en opposition à la méthode « évalue les arguments et applique ensuite » utilisée en fait par l'interpréteur, qui est appelée &lt;a2&gt;&lt;/a2&gt;&lt;e3&gt;évaluation dans l'ordre d'application&lt;/e3&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This causes the &lt;t7&gt;cond&lt;/t7&gt; to return as its value the value of the corresponding &lt;&lt;e8&gt;e&lt;/e8&gt;&gt; whenever all previous clauses have been bypassed.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T111047Z" creationid="JC Helary" creationdate="20130706T111047Z">
        <seg>Ceci force le &lt;t7&gt;cond&lt;/t7&gt; à retourner en tant que sa valeur, la valeur du &lt;&lt;e8&gt;e&lt;/e8&gt;&gt; correspondant quand toutes les clauses précédentes ont été ignorées.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This construct is called a &lt;e0&gt;case analysis&lt;/e0&gt;, and there is a special form in Lisp for notating such a case analysis.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T105238Z" creationid="JC Helary" creationdate="20130706T105238Z">
        <seg>Ce genre de construction est appelé une &lt;e0&gt;analyse de cas&lt;/e0&gt; et il existe une forme spéciale en Lisp pour les noter.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature encourages the &lt;a2&gt;&lt;/a2&gt;&lt;a3&gt;&lt;/a3&gt;incremental development and testing of programs and is largely responsible for the fact that &lt;a4&gt;&lt;/a4&gt;a Lisp program usually consists of a large number of relatively simple procedures.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T124053Z">
        <seg>Cette fonction encourage le &lt;a2&gt;&lt;/a2&gt;&lt;a3&gt;&lt;/a3&gt;développement et les tests incrémentiels de programmes et est en grande partie responsable du fait qu'un &lt;a4&gt;&lt;/a4&gt;programme en Lisp consiste en général d'un grand nombre de procédures relativement simples.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This gives the same answer as our previous evaluation model, but the process is different.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T110003Z">
        <seg>La réponse est la même que le modèle précédent mais le processus est différent.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is not the only way to perform evaluation.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T103647Z">
        <seg>Ceci n'est pas la seule façon de procéder à une évaluation.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This memory is called the &lt;a0&gt;&lt;/a0&gt;&lt;e1&gt;environment&lt;/e1&gt; (more precisely the &lt;a2&gt;&lt;/a2&gt;&lt;e3&gt;global environment&lt;/e3&gt;, since we will see later that a computation may involve a number of different environments).&lt;a4&gt;&lt;s5&gt;&lt;s6&gt;9&lt;/s6&gt;&lt;/s5&gt;&lt;/a4&gt;</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T124345Z">
        <seg>Cette mémoire est appelée l'&lt;a0&gt;&lt;/a0&gt;&lt;e1&gt;environnement&lt;/e1&gt; (ou plus précisément l'&lt;a2&gt;&lt;/a2&gt;&lt;e3&gt;environnement global&lt;/e3&gt;, puisque nous verrons plus tard qu'un calcul peut impliquer un certain nombre d'environnements différents).&lt;a4&gt;&lt;s5&gt;&lt;s6&gt;9&lt;/s6&gt;&lt;/s5&gt;&lt;/a4&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This mode of operation is often expressed by saying that the interpreter runs in a &lt;a0&gt;&lt;/a0&gt;&lt;a1&gt;&lt;/a1&gt;&lt;e2&gt;read-eval-print loop&lt;/e2&gt;.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130521T052915Z">
        <seg>Ce mode de fonctionnement est souvent décrit en disant que l'interpréteur fonctionne dans en boucle &lt;a0&gt;&lt;/a0&gt;&lt;a1&gt;&lt;/a1&gt;&lt;e2&gt;lecture-évaluation-affichage&lt;/e2&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This process continues until a predicate is found whose value is true, in which case the interpreter returns the value of the corresponding &lt;a8&gt;&lt;/a8&gt;&lt;e9&gt;consequent expression&lt;/e9&gt; &lt;&lt;e10&gt;e&lt;/e10&gt;&gt; of the clause as the value of the conditional expression.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T023833Z" creationid="JC Helary" creationdate="20130706T110053Z">
        <seg>Ce processus se poursuit jusqu'à ce que l'interpréteur trouve une proposition vraie. Il retourne alors la valeur de &lt;a8&gt;&lt;/a8&gt;&lt;e9&gt;l'expression conséquence&lt;/e9&gt; &lt;&lt;e10&gt;e&lt;/e10&gt;&gt; correspondante dans la clause en tant que valeur de l'expression conditionnelle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This uses the special form &lt;t0&gt;if&lt;/t0&gt;, a restricted type of conditional that can be used when there are precisely &lt;a1&gt;&lt;/a1&gt;two cases in the case analysis.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T111237Z" creationid="JC Helary" creationdate="20130706T111237Z">
        <seg>On utilise la forme spéciale &lt;t0&gt;if&lt;/t0&gt;, un type restreint de conditionnel qui peut être utilisé quand il y a précisément &lt;a1&gt;&lt;/a1&gt;deux cas dans l'analyse de cas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus the problem reduces to the evaluation of a combination with two operands and an operator &lt;t0&gt;sum-of-squares&lt;/t0&gt;.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T000557Z">
        <seg>Le problème se réduit ainsi à l'évaluation d'une combinaison de deux opérandes et de l'opérateur &lt;t0&gt;somme-de-carrés&lt;/t0&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, any powerful programming language should be able to describe primitive data and primitive procedures and should have methods for combining and abstracting procedures and data.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130514T052342Z">
        <seg>C'est la raison pour laquelle n'importe quel langage de programmation puissant devrait être capable de décrire des données et des procédures primitives, ainsi que de proposer des méthodes pour combiner et abstraire des données et des procédures.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, the evaluation rule is &lt;a0&gt;&lt;/a0&gt;&lt;e1&gt;recursive&lt;/e1&gt; in nature; that is, it includes, as one of its steps, the need to invoke the rule itself.&lt;a2&gt;&lt;s3&gt;&lt;s4&gt;10&lt;/s4&gt;&lt;/s3&gt;&lt;/a2&gt;</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T124950Z">
        <seg>De ce fait, la règle d'évaluation est &lt;a0&gt;&lt;/a0&gt;&lt;e1&gt;récursive&lt;/e1&gt; par nature ; c'est-à-dire qu'elle inclut dans l'une de ses étapes le besoin d'invoquer la règle elle-même.&lt;a2&gt;&lt;s3&gt;&lt;s4&gt;10&lt;/s4&gt;&lt;/s3&gt;&lt;/a2&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, when we describe a language, we should pay particular attention to the means that the language provides for combining simple ideas to form more complex ideas.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130514T051412Z">
        <seg>Quand nous décrivons un langage, une attention particulière doit être donnée aux moyens que le langage fourni pour combiner des idées simples en idées plus complexes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To apply a compound procedure to arguments, evaluate the body of the procedure with each formal parameter replaced by the corresponding argument.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130624T234310Z">
        <seg>Pour appliquer une procédure composée à des arguments, évaluer le corps de la procédure avec chaque paramètre formel remplacé par l'argument correspondant.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To evaluate a combination whose operator names a compound procedure, the interpreter follows much the same process as for combinations whose operators name primitive procedures, which we described in section &lt;a0&gt;1.1.3&lt;/a0&gt;.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130624T232305Z">
        <seg>Pour évaluer une combinaison dont l'opérateur est le nom d'une procédure composée, l'interpréteur suit en grande partie le même processus que pour les combinaisons dont les opérateurs sont le nom de procédures primitives, décrit en section &lt;a0&gt;1.1.3&lt;/a0&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To evaluate a combination, do the following:</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T124559Z">
        <seg>Pour évaluer une combinaison, suivre les étapes suivantes :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To evaluate an &lt;t0&gt;if&lt;/t0&gt; expression, the interpreter starts by evaluating the &lt;a1&gt;&lt;/a1&gt;&lt;&lt;e2&gt;predicate&lt;/e2&gt;&gt; part of the expression.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T023959Z" creationid="JC Helary" creationdate="20130706T111418Z">
        <seg>L'évaluation d'une expression &lt;t0&gt;if&lt;/t0&gt; commence par l'évaluation de la partie &lt;a1&gt;&lt;/a1&gt;&lt;&lt;e2&gt;proposition&lt;/e2&gt;&gt; de l'expression.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To illustrate this process, let's evaluate the combination</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130624T234325Z">
        <seg>Pour illustrer ce processus, évaluons la combinaison</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To      square something, multiply   it by itself.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T085706Z">
        <seg>Pour faire le carré de x, multiplier x par lui-même.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typical interpreters do not evaluate procedure applications by manipulating the text of a procedure to substitute values for the formal parameters.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T101848Z">
        <seg>Les interpréteurs n'évaluent pas les applications de procédures en manipulant le texte de la procédure pour substituer les valeurs aux paramètres formels.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Typing</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130522T151514Z">
        <seg>Saisir</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use this observation to describe the behavior of the following procedure:</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085802Z" creationid="JC Helary" creationdate="20130707T085802Z">
        <seg>Utiliser cette observation pour décrire le comportement de la procédure suivante :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Viewing evaluation in terms of the tree, we can imagine that the values of the operands percolate upward, starting from the terminal nodes and then combining at higher and higher levels.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T125628Z">
        <seg>La visualisation de l'évaluation sous la forme d'un arbre permet d'imaginer que les valeurs des opérandes remontent vers le haut, en partant des nœuds terminaux et en se combinant à des niveaux de plus en plus élevés.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We begin by examining how to express the idea of ``squaring.'' We might say, ``To square something, multiply it by itself.'' This is expressed in our language as</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T104155Z">
        <seg>Commençons par voir comment exprimer l'idée de « mettre au carré ». On peut dire, « Pour mettre quelque chose au carré, il faut multiplier cette chose par elle-même ». Dans notre langage ceci est exprimé de cette manière</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We begin by retrieving the body of &lt;t2&gt;f&lt;/t2&gt;:</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130624T234404Z">
        <seg>Commençons par retrouver le corps de &lt;t2&gt;f&lt;/t2&gt; :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can also use &lt;t0&gt;square&lt;/t0&gt; as a building block in defining other procedures.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T110224Z">
        <seg>Nous pouvons également utiliser &lt;t0&gt;carré&lt;/t0&gt; comme bloc pour définir d'autres procédures.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can assume that the mechanism for applying primitive procedures to arguments is built into the interpreter.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130624T232459Z">
        <seg>Nous pouvons considérer que le mécanisme pour appliquer des procédures primitives aux arguments est construit dans l'interpréteur.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can easily define a procedure &lt;t0&gt;sum-of-squares&lt;/t0&gt; that, given any two numbers as arguments, produces the sum of their squares:</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T110432Z">
        <seg>Nous pouvons facilement définir une procédure &lt;t0&gt;somme-de-carrés&lt;/t0&gt; qui, avec deux nombres comme arguments, produira la somme de leurs carrés :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can help ourselves by writing such an expression in the form</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T085216Z">
        <seg>Nous pouvons nous faciliter la tâche en écrivant une telle expression sous la forme</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can obtain a picture of this process by &lt;a0&gt;&lt;/a0&gt;representing the combination in the form of a &lt;a1&gt;&lt;/a1&gt;tree, as shown in figure &lt;a2&gt;1.1&lt;/a2&gt;.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T125253Z">
        <seg>Nous pouvons obtenir une image de ce processus en &lt;a0&gt;&lt;/a0&gt;représentant la combinaison sous la forme d'un &lt;a1&gt;&lt;/a1&gt;arbre, comme dans la figure &lt;a2&gt;1.1&lt;/a2&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can understand this in the following way:</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T104227Z">
        <seg>Nous pouvons comprendre ceci de la manière suivante :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We have here a &lt;e0&gt;compound procedure&lt;/e0&gt;, which has been given the name &lt;t1&gt;square&lt;/t1&gt;.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T104308Z">
        <seg>Nous avons ici une &lt;e0&gt;procédure composée&lt;/e0&gt; à qui le nom &lt;t1&gt;carré&lt;/t1&gt; a été donnée.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We have identified in Lisp some of the elements that must appear in any powerful programming language:</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T103311Z">
        <seg>Nous avons identifié dans Lisp quelques éléments qui doivent apparaitre dans n'importe quel langage de programmation puissant :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We may regard the second rule as a special case of the third one by stipulating that symbols such as &lt;t0&gt;+&lt;/t0&gt; and &lt;t1&gt;*&lt;/t1&gt; are also included in the global environment, and are associated with the sequences of machine instructions that are their ``values.'' The key point to notice is the role of the &lt;a2&gt;&lt;/a2&gt;environment in determining the meaning of the symbols in expressions.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130623T042649Z">
        <seg>On peut considérer la seconde règle comme un cas particulier de la troisième en déclarant que les symboles tels que &lt;t0&gt;+&lt;/t0&gt; et &lt;t1&gt;*&lt;/t1&gt; sont aussi inclus dans l'environnement global et sont associés aux séquences d'instruction machine qui sont leurs « valeurs ». Le point clé à considérer est le rôle de &lt;a2&gt;&lt;/a2&gt;l'environnement dans la détermination de la signification des symboles dans les expressions.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We must evaluate the operator to get the procedure to be applied, and we must evaluate the operands to get the arguments.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T000819Z">
        <seg>Nous devons évaluer l'opérateur pour que la procédure soit appliquée, et nous devons évaluer les opérandes pour obtenir les arguments.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We say that the &lt;a1&gt;&lt;/a1&gt;name identifies a &lt;a2&gt;&lt;/a2&gt;&lt;e3&gt;variable&lt;/e3&gt; whose &lt;a4&gt;&lt;/a4&gt;&lt;e5&gt;value&lt;/e5&gt; is the object.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130521T054407Z">
        <seg>Nous disons que le &lt;a1&gt;&lt;/a1&gt;nom identifie une &lt;a2&gt;&lt;/a2&gt;&lt;e3&gt;variable&lt;/e3&gt; dont la &lt;a4&gt;&lt;/a4&gt;&lt;e5&gt;valeur&lt;/e5&gt; est l'objet,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We take care of the primitive cases by stipulating that</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T130112Z">
        <seg>Nous traitons les cas de primitives en stipulant que</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We will discuss this more fully in chapters 3 and 4 when we examine the implementation of an interpreter in detail.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T103452Z">
        <seg>Nous aborderons ceci de manière plus approfondie dans les chapitres 3 et 4 quand nous examinerons l'implémentation d'un interpréteur en détail.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What is the result printed by the interpreter in response to each expression?</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085419Z" creationid="JC Helary" creationdate="20130707T085419Z">
        <seg>Quel est le résultat présenté par l'interpréteur en réponse à chacune de ces expressions ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You type an &lt;e0&gt;expression&lt;/e0&gt;, and the interpreter responds by displaying the result of its &lt;e1&gt;evaluating&lt;/e1&gt; that expression.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T123543Z">
        <seg>Vous saisissez une &lt;e0&gt;expression&lt;/e0&gt; et l'interpréteur répond en affichant le résultat de son &lt;e1&gt;évaluation&lt;/e1&gt; de cette expressions.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[Go to &lt;s0&gt;&lt;a1&gt;first&lt;/a1&gt;, &lt;a2&gt;previous&lt;/a2&gt;&lt;/s0&gt;&lt;s3&gt;, &lt;a4&gt;next&lt;/a4&gt;&lt;/s3&gt; page&lt;s5&gt;;   &lt;/s5&gt;&lt;s6&gt;&lt;a7&gt;contents&lt;/a7&gt;&lt;/s6&gt;&lt;s8&gt;&lt;s9&gt;;   &lt;/s9&gt;&lt;a10&gt;index&lt;/a10&gt;&lt;/s8&gt;]</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T123737Z">
        <seg>[Aller à la &lt;s0&gt;&lt;a1&gt;première&lt;/a1&gt; page, à la page &lt;a2&gt;précédente&lt;/a2&gt;&lt;/s0&gt;&lt;s3&gt;, &lt;a4&gt;suivante&lt;/a4&gt;&lt;/s3&gt;&lt;s5&gt; ; &lt;/s5&gt;&lt;s6&gt;&lt;a7&gt;table des matières&lt;/a7&gt;&lt;/s6&gt;&lt;s8&gt;&lt;s9&gt; ; &lt;/s9&gt;&lt;a10&gt;index&lt;/a10&gt;&lt;/s8&gt;]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[Go to &lt;s0&gt;&lt;a1&gt;first&lt;/a1&gt;, &lt;a2&gt;previous&lt;/a2&gt;&lt;/s0&gt;&lt;s3&gt;, &lt;a4&gt;next&lt;/a4&gt;&lt;/s3&gt; page&lt;s5&gt;;   &lt;/s5&gt;&lt;s6&gt;contents&lt;/s6&gt;&lt;s7&gt;&lt;s8&gt;;   &lt;/s8&gt;&lt;a9&gt;index&lt;/a9&gt;&lt;/s7&gt;]</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130513T155120Z">
        <seg>[Aller à la &lt;s0&gt;&lt;a1&gt;première&lt;/a1&gt; page, à la page &lt;a2&gt;précédente&lt;/a2&gt;&lt;/s0&gt;&lt;s3&gt;, &lt;a4&gt;suivante&lt;/a4&gt;&lt;/s3&gt;&lt;s5&gt; ;   &lt;/s5&gt;&lt;s6&gt;table des matières&lt;/s6&gt;&lt;s7&gt;&lt;s8&gt; ;   &lt;/s8&gt;&lt;a9&gt;index&lt;/a9&gt;&lt;/s7&gt;]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[Go to &lt;s0&gt;first, previous&lt;/s0&gt;&lt;s1&gt;&lt;s2&gt;, &lt;/s2&gt;&lt;a3&gt;next&lt;/a3&gt;&lt;/s1&gt; page&lt;s4&gt;;</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="Didier" changedate="20130528T134153Z">
        <seg>[Go to &lt;s0&gt;first, previous&lt;/s0&gt;&lt;s1&gt;&lt;s2&gt;, &lt;/s2&gt;&lt;a3&gt;next&lt;/a3&gt;&lt;/s1&gt; page&lt;s4&gt;;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[Go to &lt;s0&gt;first, previous&lt;/s0&gt;&lt;s1&gt;&lt;s2&gt;, &lt;/s2&gt;&lt;a3&gt;next&lt;/a3&gt;&lt;/s1&gt; page&lt;s4&gt;;   &lt;/s4&gt;&lt;s5&gt;&lt;a6&gt;contents&lt;/a6&gt;&lt;/s5&gt;&lt;s7&gt;&lt;s8&gt;;   &lt;/s8&gt;&lt;a9&gt;index&lt;/a9&gt;&lt;/s7&gt;]</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T123750Z">
        <seg>[Aller à la &lt;s0&gt;première page, à la page précédente&lt;/s0&gt;&lt;s1&gt;&lt;s2&gt;, &lt;/s2&gt;&lt;a3&gt;suivante&lt;/a3&gt;&lt;/s1&gt;&lt;s4&gt; ; &lt;/s4&gt;&lt;s5&gt;&lt;a6&gt;table des matières&lt;/a6&gt;&lt;/s5&gt;&lt;s7&gt;&lt;s8&gt; ; &lt;/s8&gt;&lt;a9&gt;index&lt;/a9&gt;&lt;/s7&gt;]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a)</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085457Z" creationid="JC Helary" creationdate="20130707T085457Z">
        <seg>a)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and finally to</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T001122Z">
        <seg>et finalement à</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>b</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085456Z" creationid="JC Helary" creationdate="20130707T085456Z">
        <seg>b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>causes the interpreter to associate the value 2 with the name &lt;t0&gt;size&lt;/t0&gt;.&lt;a1&gt;&lt;s2&gt;&lt;s3&gt;8&lt;/s3&gt;&lt;/s2&gt;&lt;/a1&gt; Once the name &lt;t4&gt;size&lt;/t4&gt; has been associated with the number 2, we can refer to the value 2 by name:</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130524T083524Z">
        <seg>fait associer à l'interpréteur la valeur 2 au nom &lt;t0&gt;taille&lt;/t0&gt;.&lt;a1&gt;&lt;s2&gt;&lt;s3&gt;8&lt;/s3&gt;&lt;/s2&gt;&lt;/a1&gt; Une fois le nom &lt;t4&gt;taille&lt;/t4&gt; associé au nombre 2, il est possible de faire référence à la valeur 2 à l'aide de son nom.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>circumference</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130522T151746Z">
        <seg>circonference</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>consisting of the symbol &lt;t0&gt;cond&lt;/t0&gt; followed by &lt;a1&gt;&lt;/a1&gt;parenthesized pairs of expressions &lt;t2&gt;(&lt;&lt;e3&gt;p&lt;/e3&gt;&gt; &lt;&lt;e4&gt;e&lt;/e4&gt;&gt;)&lt;/t2&gt; called &lt;a5&gt;&lt;/a5&gt;&lt;a6&gt;&lt;/a6&gt;&lt;e7&gt;clauses&lt;/e7&gt;.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T105447Z" creationid="JC Helary" creationdate="20130706T105447Z">
        <seg>qui consiste du symbole &lt;t0&gt;cond&lt;/t0&gt; suivi par &lt;a1&gt;&lt;/a1&gt;des paires d'expressions entre parenthèses &lt;t2&gt;(&lt;&lt;e3&gt;p&lt;/e3&gt;&gt; &lt;&lt;e4&gt;e&lt;/e4&gt;&gt;)&lt;/t2&gt; appelées &lt;a5&gt;&lt;/a5&gt;&lt;a6&gt;&lt;/a6&gt;&lt;e7&gt;clauses&lt;/e7&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>default</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130524T091110Z">
        <seg>default</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>followed by the reductions</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T105848Z">
        <seg>suivie par les réductions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>following a formatting convention known as &lt;a0&gt;&lt;/a0&gt;&lt;e1&gt;pretty-printing&lt;/e1&gt;, in which each long combination is written so that the operands are aligned vertically.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T123456Z">
        <seg>grâce à une convention d'&lt;a0&gt;&lt;/a0&gt;&lt;e1&gt;impression élégante&lt;/e1&gt; selon laquelle toute combinaison longue est écrite de manière à ce que les opérandes soient alignées verticalement.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>foreword by Alan J. Perlis</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130513T154126Z">
        <seg>Avant-propos de Alan J. Perlis</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>of Computer Programs</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130513T154059Z">
        <seg>des programmes informatiques</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or alternatively as</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T085317Z" creationid="JC Helary" creationdate="20130707T085317Z">
        <seg>ou alternativement de cette manière</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>requires that the evaluation rule be applied to four different combinations.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T125208Z">
        <seg>demande que la règle d'évaluation soit appliquée à quatre combinaisons différentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>second edition</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130513T154104Z">
        <seg>Seconde édition</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>size</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130522T151656Z">
        <seg>taille</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the interpreter will respond by printing&lt;a0&gt;&lt;s1&gt;&lt;s2&gt;5&lt;/s2&gt;&lt;/s1&gt;&lt;/a0&gt;</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T010905Z">
        <seg>l'interpréteur répondra en affichant&lt;a0&gt;&lt;s1&gt;&lt;s2&gt;5&lt;/s2&gt;&lt;/s1&gt;&lt;/a0&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the values of built-in operators are the machine instruction sequences that carry out the corresponding operations, and</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T130220Z">
        <seg>la valeur des opérateurs *** sont les séquences d'instruction machine qui effectuent l'opération correspondant, et</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the values of numerals are the numbers that they name,</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T130143Z">
        <seg>la valeur de numéraux est le nombre qu'ils représentent,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the values of other names are the objects associated with those names in the environment.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130621T130241Z">
        <seg>la valeur des autres noms est les objets associés à ces noms dans l'environnement.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>where &lt;t0&gt;f&lt;/t0&gt; is the procedure defined in section &lt;a1&gt;1.1.4&lt;/a1&gt;.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130624T234347Z">
        <seg>où &lt;t0&gt;f&lt;/t0&gt; est la procédure définie en section &lt;a1&gt;1.1.4&lt;/a1&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which could be expressed in English as ``If &lt;e0&gt;x&lt;/e0&gt; is less than zero return - &lt;e1&gt;x&lt;/e1&gt;; otherwise return &lt;e2&gt;x&lt;/e2&gt;.'' &lt;a3&gt;&lt;/a3&gt;&lt;t4&gt;Else&lt;/t4&gt; is a special symbol that can be used in place of the &lt;&lt;e5&gt;p&lt;/e5&gt;&gt; in the final clause of a &lt;t6&gt;cond&lt;/t6&gt;.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T110746Z" creationid="JC Helary" creationdate="20130706T110746Z">
        <seg>qui peut s'exprimer en français de la manière suivante : « si &lt;e0&gt;x&lt;/e0&gt; est inférieur à zéro, retourne - &lt;e1&gt;x&lt;/e1&gt; autrement retourne &lt;e2&gt;x&lt;/e2&gt;. » &lt;a3&gt;&lt;/a3&gt;&lt;t4&gt;Else&lt;/t4&gt; est un symbole spécial qui peut être utilisé à la place de &lt;&lt;e5&gt;p&lt;/e5&gt;&gt; dans la clause finale d'un &lt;t6&gt;cond&lt;/t6&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which reduces by multiplication to</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T001117Z">
        <seg>ce qui se réduit à</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which the interpreter would readily evaluate to be 57.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130515T085147Z">
        <seg>que l'interpréteur aurait évalué immédiatement à 57.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with &lt;t0&gt;x&lt;/t0&gt; replaced respectively by &lt;t1&gt;(+ 5 1)&lt;/t1&gt; and &lt;t2&gt;(* 5 2)&lt;/t2&gt;.</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T110150Z">
        <seg>avec &lt;t0&gt;x&lt;/t0&gt; remplacé respectivement par &lt;t1&gt;(+ 5 1)&lt;/t1&gt; et &lt;t2&gt;(*5 2)&lt;/t2&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>with Julie Sussman</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="jchelary" changedate="20130513T154113Z">
        <seg>avec Julie Sussman</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>would proceed according to the sequence of expansions</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130625T105823Z">
        <seg>se déroulerait selon la suite d'expansions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130706T111151Z" creationid="JC Helary" creationdate="20130706T111151Z">
        <seg>x))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>y))</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="JC Helary" changedate="20130707T133244Z" creationid="JC Helary" creationdate="20130707T133244Z">
        <seg>y))</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>  &lt;/s4&gt;&lt;s5&gt;&lt;a6&gt;contents&lt;/a6&gt;&lt;/s5&gt;&lt;s7&gt;&lt;s8&gt;;</seg>
      </tuv>
      <tuv lang="FR-FR" changeid="Didier" changedate="20130528T134200Z">
        <seg>  &lt;/s4&gt;&lt;s5&gt;&lt;a6&gt;contents&lt;/a6&gt;&lt;/s5&gt;&lt;s7&gt;&lt;s8&gt;;</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
